---
layout: post
title: Mini App Killer
description: A mini lightweight application created in .NET C# that will sit in your system tray for easy access to simply kill or end task any running application.
keywords: c# programming, mini app killer, end task process, system tray, notify icon
tags: [CSharp, WPF]
comments: true
---

Mini App Killer is a mini lightweight application I created in .NET C# that will sit in your system tray for easy access to simply kill or end task any running application. Other than terminating the running application, you also can open the running application directory (Open file location) or show application File Properties.

[**Download MiniAppKillerV1.zip**](https://www.dropbox.com/s/4gibswk7iz7gg9d/MiniAppKillerV1.zip?dl=0) Â· 55.2 KB

By default, Mini App Killer program will list all running applications or processes that contain `MainWindowTitle` property from WMI query.

C# code snippet:

```csharp
var wmiQueryString = "SELECT ProcessId, ExecutablePath FROM Win32_Process";
using(var searcher = new ManagementObjectSearcher(wmiQueryString))
using(var results = searcher.Get()) {
    var query = from p in Process.GetProcesses()
    join mo in results.Cast<ManagementObject>()
    on p.Id equals(int)(uint) mo["ProcessId"]
    select new {
        Process = p,
        Path = (string)mo["ExecutablePath"],
    };

    if (query.Count() > 0) {
        foreach(var item in query) {
            if (!string.IsNullOrEmpty(item.Process.MainWindowTitle)) {
                // List all running application here...
            }
        }
    }
}
```

Screenshot:

![Listing all running applications](http://i.imgur.com/z5hJFH8.png)

![To kill the running application](http://i.imgur.com/TJG1sV1.png)

Here are the C# code I use to kill the application, open file location or show application File Properties from the WMI query results:

```csharp
// To kill the running application based on Process Id.
Process.GetProcessById(item.Process.Id).Kill();

// To open the running application directory and select the executable file.
Process.Start("explorer.exe", "/select, \"" + item.Path + "\"");

// To show the application File Properties
ShowFileProperties(item.Path);

#region Unmanaged code for ShowFileProperties(path)
[DllImport("shell32.dll", CharSet = CharSet.Auto)]
private static extern bool ShellExecuteEx(ref SHELLEXECUTEINFO lpExecInfo);

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
public struct SHELLEXECUTEINFO {
    public int cbSize;
    public uint fMask;
    public IntPtr hwnd;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string lpVerb;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string lpFile;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string lpParameters;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string lpDirectory;
    public int nShow;
    public IntPtr hInstApp;
    public IntPtr lpIDList;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string lpClass;
    public IntPtr hkeyClass;
    public uint dwHotKey;
    public IntPtr hIcon;
    public IntPtr hProcess;
}

private const int SW_SHOW = 5;
private const uint SEE_MASK_INVOKEIDLIST = 12;
public static bool ShowFileProperties(string Filename) {
    SHELLEXECUTEINFO info = new SHELLEXECUTEINFO();
    info.cbSize = System.Runtime.InteropServices.Marshal.SizeOf(info);
    info.lpVerb = "properties";
    info.lpFile = Filename;
    info.nShow = SW_SHOW;
    info.fMask = SEE_MASK_INVOKEIDLIST;
    return ShellExecuteEx(ref info);
}
#endregion
```

#### Customize filter...

To filter for specific process name (application executable name without extension), there is a function called "Customize filter..." on the Mini App Killer. When you click it, a window for adding process name will be shown as below:

![Customize filter...](http://i.imgur.com/CxYg1gU.png)

Then, Mini App Killer program will list all running application that contain the process name as defined in the "Customize filter..." window when "Enable filtered by process name..." checkbox is checked.

![Filtered by process name](http://i.imgur.com/jHb3HqI.png)

This is how WMI query code looked like for filtering the target process names:

```csharp
string[] _targetProcessNames = ... // Array of process names to filter..

var query = from p in Process.GetProcesses()
            where _targetProcessNames.Any(n => n.Equals(p.ProcessName, StringComparison.InvariantCultureIgnoreCase))
            join mo in results.Cast<ManagementObject>()
            on p.Id equals(int)(uint) mo["ProcessId"]
            select new {
              Process = p,
              Path = (string)mo["ExecutablePath"],
            };
```

#### App settings

All filtered process names will be saved to a text file named as `filters.txt`, which is easy for user to read or modify directly from the file.

filters.txt:

```
# This file is auto-generated by Mini App Killer
chrome
ccleaner64
```

I use `.ini` file for saving the Mini App Killer application settins as it's simple and easy. This is the class to read and write `.ini` file:

```csharp
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace Helpers
{
    public class IniFile
    {
        private string Path;
        private string EXE = Assembly.GetExecutingAssembly().GetName().Name;

        [DllImport("kernel32", CharSet = CharSet.Unicode)]
        private static extern long WritePrivateProfileString(string Section, string Key, string Value, string FilePath);

        [DllImport("kernel32", CharSet = CharSet.Unicode)]
        private static extern int GetPrivateProfileString(string Section, string Key, string Default, StringBuilder RetVal, int Size, string FilePath);

        public IniFile(string IniPath = null)
        {
            Path = new FileInfo(IniPath ?? EXE + ".ini").FullName.ToString();
        }

        public string Read(string Key, string Section = null)
        {
            var RetVal = new StringBuilder(255);
            GetPrivateProfileString(Section ?? EXE, Key, "", RetVal, 255, Path);
            return RetVal.ToString();
        }

        public void Write(string Key, string Value, string Section = null)
        {
            WritePrivateProfileString(Section ?? EXE, Key, Value, Path);
        }

        public void DeleteKey(string Key, string Section = null)
        {
            Write(Key, null, Section ?? EXE);
        }

        public void DeleteSection(string Section = null)
        {
            Write(null, null, Section ?? EXE);
        }

        public bool KeyExists(string Key, string Section = null)
        {
            return Read(Key, Section).Length > 0;
        }
    }
}
```
